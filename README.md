# FRA333_HW3_6568_6576

ชื่อ_รหัส

1.ชุตินันท์_6568

2.สิปปนนท์_6576

```
#NOTE ระวังกด Run แล้วบัคแสดงออกมาไม่ครบ 6x6 matrix ให้กด Run ใหม่อีกรอบ
```

# การตรวจคำตอบบนไฟล์ testScript.py

## Table of Content

> 0. วิธีการใช้งานโค้ดทั้ง 2 ไฟล์
> 1. แนวคิดการตรวจคำตอบ
> 2. วิธีการตรวจคำตอบ
>> - ตรวจคำตอบข้อที่ 1
>> - ตรวจคำตอบข้อที่ 2
>> - ตรวจคำตอบข้อที่ 3

- - - - - - - - - - - - - - - - - - - - - -
### 0. วิธีการใช้งาน Code ทั้ง 2 ไฟล์

โค้ดของ FRA333_HW3_6568_6576.py และ testScript.py 

จะมีการกำหนดค่า q และ w ที่อยู่บริเวณด้านท้ายสุดของ Code 

>ใน FRA333_HW3_6568_6576.py โค้ดจะอยู่บริเวณบรรทัดที่ 121 ถึง 123 ผู้ใช้โค้ดสามารถปรับแก้ได้ตามความสนใจ

>ใน testScript.py โค้ดจะอยู่บริเวณบรรทัดที่ 110 ถึง 112 ผู้ใช้โค้ดสามารถปรับแก้ได้ตามความสนใจ
 ```
q = [0.0,0.0,0.0]                #<--- INSERT Q HERE !
# q = [0.0,-pi/2,-0.2]           # ค่าที่ทำให้เกิด Singularity
w = [10, 0, 0, 0, 0, 0]          #<---- Inset w Here !
  ```
จากนั้นกด Run โค้ดได้เลย ผลลัพธ์ที่ได้จะเป็นดังตัวอย่างนี้ 

```
This RRR robot Jacobian(manual calculation) is:    
 [[-1.09000000e-01 -9.30000000e-02 -9.30000000e-02]
 [ 8.99430000e-01  6.64634217e-17  4.04396760e-17] 
 [ 0.00000000e+00 -8.99430000e-01 -4.74430000e-01] 
 [ 0.00000000e+00  1.22464685e-16  1.22464685e-16] 
 [ 0.00000000e+00  1.00000000e+00  1.00000000e+00] 
 [ 1.00000000e+00  6.12323426e-17  6.12323426e-17]]


################# คำตอบข้อ 2 #################     
Flag = 0: Not in singularity.


################# คำตอบข้อ 3 #################     
tau is
 [-1.09 -0.93 -0.93]
```

- - - - - - - - - - - - - - - - - - - - - -
### 1. แนวคิดการตรวจคำตอบ

ส่วนของการตรวจคำตอบในไฟล์ testScript.py คือการตรวจโดยใช้ roboticstoolbox ในการคำนวณปัญหาของโจทย์ 

ทดลองใส่ค่า q และ w เมื่อคำนวนเสร็จสิ้นให้นำไปเทียบกับ คำตอบที่อยู่ในไฟล์ FRA333_HW3_6568_6576.py 

ตรวจสอบว่าคำตอบใน FRA333_HW3_6568_6576.py ถูกหรือไม่

- - - - - - - - - - - - - - - - - - - - - -

### 2. วิธีการตรวจคำตอบ
2.1. ขั้นตอนที่หนึ่ง import libary ที่จำเป็น และ ดึงไฟล์จาก HW3_utils มาใช้
```
import numpy as np
import sympy as sp
from math import pi
import roboticstoolbox as rtb
from spatialmath import SE3
from HW3_utils import FKHW3 
```

2.2. ขั้นตอนที่สอง คำนวณตำแหน่งและการหมุนของ end-effector
```
# กำหนดตัวแปรที่จะใช้งาน
d_1 = 0.0892
a_2 = -0.425
a_3 = -0.39243
d_4 = 0.109
d_5 = 0.093
d_6 = 0.082
c_minus_90 = 0
s_minus_90 = -1

# หา End effector และสร้าง rbot
# คำนวณตำแหน่งและการหมุนของ end-effector
End_P = np.array([a_3 + (-d_6), -d_5 , d_4]) # ตำแหน่งของ end-effector
End_R = np.array([[c_minus_90,      0,  s_minus_90], # เมทริกซ์การหมุน
                  [0,               1,           0],
                  [-(s_minus_90),   0,  c_minus_90]])
End = np.eye(4)  # สร้างเมทริกซ์ขนาด 4x4
End[0:3, 3] = End_P # กำหนดส่วนของตำแหน่งในเมทริกซ์
End[0:3, 0:3] = End_R # กำหนดส่วนของการหมุนในเมทริกซ์
End_EF = SE3(End) # กำหนด end effector ในรูปแบบ SE3 (การแปลงHomogeneous)
# print('End_EF is \n', End_EF)
```

2.3. ขั้นตอนที่สาม ทำการสร้าง DH parameter โดยใช้ตัวแปรชื่อ rbot
```
# กำหนดโมเดลหุ่นยนต์โดยใช้ DH Parameter
rbot = rtb.DHRobot(
    [
        rtb.RevoluteMDH(a= 0, d= d_1, offset=pi),
        rtb.RevoluteMDH(a= 0, alpha= pi/2),
        rtb.RevoluteMDH(a= a_2)
    ],
    tool = End_EF,
    name = "RRR_Rbot"
)
```
หลังจากทำ 2.1 , 2.2 และ 2.3 ครบแล้วจะเริ่มทำการตรวจคำตอบข้อที่ 1



### -----< การตรวจคำตอบข้อที่ 1 >-----

หลังจากได้ rbot แล้ว นำมาใส่ใน .jacob0 เพื่อคำนวณหาค่า J_e โดยรับ q เป็น input
```
def TestJacobianHW3(q:list[float])->list[float]:
    print('################# ตรวจคำตอบข้อ 1 #################')

    J_e = rbot.jacob0(q) #คำนวณหา jacobian matrix โดยใช้ jacob0
    print("This RRR robot Jacobian is: \n",J_e) 

    print('\n')
    return J_e
```
คำตอบที่ได้ เมื่อกำหนดให้ q = [0.0,0.0,0.0]
```
################# ตรวจคำตอบข้อ 1 #################
This RRR robot Jacobian is: 
 [[-1.09000000e-01 -9.30000000e-02 -9.30000000e-02]
 [ 8.99430000e-01  6.64634188e-17  4.04396743e-17] 
 [ 0.00000000e+00 -8.99430000e-01 -4.74430000e-01] 
 [ 0.00000000e+00  1.22464680e-16  1.22464680e-16] 
 [ 0.00000000e+00  1.00000000e+00  1.00000000e+00] 
 [ 1.00000000e+00  6.12323400e-17  6.12323400e-17]]
```

### -----< การตรวจคำตอบข้อที่ 2 >-----

```
def TestSingularityHW3(q:list[float])->bool:

    #กำหนดตัวแปร
    epsilon = 0.001
    J_e = rbot.jacob0(q)  

    # ใช้แค่ค่าของ Linear Velocity จึงทำการนำส่วนเชิงเส้นของ Jacobian matrix ออกมา โดยใช้ [:3, :]
    J_e_linear = J_e[:3, :]

    # หาค่า det ของ J_e_linear โดยใช้ numpy
    det_J_linear = np.linalg.det(J_e_linear)

    # สร้างตัวแปร Lเพื่อเก็บค่า absolute ของ det_J_linear
    L = abs(det_J_linear)

    # ตรวจสอบว่าหุ่นเข้าใกล้ค่า Singularity ไหม ผ่านการเปรียบเทียบกับ epsilon
    if abs(L) < epsilon:
        print('################# ตรวจคำตอบข้อ 2 #################')
        print(" Flag = 1 is singularity.")
        print('\n')
        return 1
    else:
        print('################# ตรวจคำตอบข้อ 2 #################')
        print(" Flag = 0 is not singularity.")
        print('\n')
        return 0
```
คำตอบที่ได้ เมื่อกำหนดให้ q = [0.0,0.0,0.0]
```
################# ตรวจคำตอบข้อ 2 ################# 
 Flag = 0 is not singularity.
```


### -----< การตรวจคำตอบข้อที่ 3 >-----

```
def TestcomputeEffortHW3(q:list[float], w:list[float])->list[float]:
    print('################# ตรวจคำตอบข้อ 3 #################')
    
    #กำหนดตัวแปร
    J_e = rbot.jacob0(q)

    # คำนวณแรงบิด
    #ใช้ numpy ในการหาค่า tau โดยนำ J_e.T dot w
    # tau = rbot.pay(w, q, J_e)
    tau = np.dot(J_e.T, w)
    print('tau is \n', tau)
    print('\n')
    return tau
```

คำตอบที่ได้ เมื่อกำหนดให้ q = [0.0,0.0,0.0] และ w = [10, 0, 0, 0, 0, 0]  

```
################# ตรวจคำตอบข้อ 3 ################# 
tau is 
 [-1.09 -0.93 -0.93]
```
